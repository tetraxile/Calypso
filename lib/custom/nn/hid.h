/**
 * @file hid.h
 * @brief Functions that help process gamepad inputs.
 */

#pragma once

#include <nn/os/os_MutexTypes.h>
#include <nn/types.h>
#include <nn/util.h>
#include <nn/util/MathTypes.h>
#include <nn/util/util_BitFlagSet.h>
#include <nn/xcd.h>

namespace nn {
namespace hid {

// todo: does something like this exist in nn?
typedef util::Color4u8Type Color4u8;

enum class NpadButton {
	A = 0,
	B = 1,
	X = 2,
	Y = 3,
	StickL = 4,
	StickR = 5,
	L = 6,
	R = 7,
	ZL = 8,
	ZR = 9,
	Plus = 10,
	Minus = 11,
	Left = 12,
	Up = 13,
	Right = 14,
	Down = 15,
	StickLLeft = 16,
	StickLUp = 17,
	StickLRight = 18,
	StickLDown = 19,
	StickRLeft = 20,
	StickRUp = 21,
	StickRRight = 22,
	StickRDown = 23,
	LeftSL = 24,
	LeftSR = 25,
	RightSL = 26,
	RightSR = 27,
	Palma = 28,
	Verification = 29,
	HandheldLeftB = 30, // (Left B button on NES controllers in Handheld mode)
#if NN_SDK_VER >= NN_MAKE_VER(12, 0, 0)
	LeftC = 31,  // (Left C button in N64 controller)
	UpC = 32,    // (Up C button in N64 controller)
	RightC = 33, // (Right C button in N64 controller)
	DownC = 34,  // (Down C button in N64 controller)
#endif
};

enum class NpadAttribute {
	IsConnected = 0,
	IsWired = 1,
	IsLeftConnected = 2,
	IsLeftWired = 3,
	IsRightConnected = 4,
	IsRightWired = 5,
};

enum class NpadStyleTag {
	NpadStyleFullKey = 0,  // (Pro Controller)
	NpadStyleHandheld = 1, // (Joy-Con controller in handheld mode)
	NpadStyleJoyDual = 2,  // (Joy-Con controller in dual mode)
	NpadStyleJoyLeft = 3,  // (Joy-Con left controller in single mode)
	NpadStyleJoyRight = 4, // (Joy-Con right controller in single mode)
#if NN_SDK_VER <= NN_MAKE_VER(3, 5, 1)
	NpadStyleInvalid = 5,
#else
	NpadStyleGc = 5,           // (GameCube controller)
	NpadStylePalma = 6,        // (PokÃ© Ball Plus controller)
	NpadStyleLark = 7,         // (NES/Famicom controller)
	NpadStyleHandheldLark = 8, // (NES/Famicom controller in handheld mode)
	NpadStyleLucia = 9,        // (SNES controller)
# if NN_SDK_VER >= NN_MAKE_VER(12, 0, 0)
	NpadStyleLagon = 10, // (N64 controller)
# endif
# if NN_SDK_VER >= NN_MAKE_VER(13, 0, 0)
	NpadStyleLager = 11, // (Sega Genesis controller)
# endif
	// bits 12-28 Reserved
	NpadStyleSystemExt = 29, // (generic external controller)
	NpadStyleSystem = 30,    // (generic controller)
// bit 31 Reserved
#endif
};

enum class NpadSystemProperties {
	IsChargingJoyDual = 0,
	IsChargingJoyLeft = 1,
	IsChargingJoyRight = 2,
	IsPoweredJoyDual = 3,
	IsPoweredJoyLeft = 4,
	IsPoweredJoyRight = 5,
	IsUnsuportedButtonPressedOnNpadSystem = 9,
	IsUnsuportedButtonPressedOnNpadSystemExt = 10,
	IsAbxyButtonOriented = 11,
	IsSlSrButtonOriented = 12,
#if NN_SDK_VER >= NN_MAKE_VER(4, 0, 0)
	IsPlusAvailable = 13,
	IsMinusAvailable = 14,
#endif
#if NN_SDK_VER >= NN_MAKE_VER(8, 0, 0)
	IsDirectionalButtonsAvailable = 15,
#endif
};

enum class NpadSystemButtonProperties { IsUnintendedHomeButtonInputProtectionEnabled };

enum class TouchAttribute { Transferable = 0, IsConnected = 1 };

enum class MouseButton { Left, Right, Middle, Forward, Back };

enum class MouseAttribute { Transferable, IsConnected };

enum class KeyboardKey {
	A = 4,
	B = 5,
	C = 6,
	D = 7,
	E = 8,
	F = 9,
	G = 10,
	H = 11,
	I = 12,
	J = 13,
	K = 14,
	L = 15,
	M = 16,
	N = 17,
	O = 18,
	P = 19,
	Q = 20,
	R = 21,
	S = 22,
	T = 23,
	U = 24,
	V = 25,
	W = 26,
	X = 27,
	Y = 28,
	Z = 29,
	D1 = 30,
	D2 = 31,
	D3 = 32,
	D4 = 33,
	D5 = 34,
	D6 = 35,
	D7 = 36,
	D8 = 37,
	D9 = 38,
	D0 = 39,
	Return = 40,
	Escape = 41,
	Backspace = 42,
	Tab = 43,
	Space = 44,
	Minus = 45,
	Plus = 46,
	OpenBracket = 47,
	CloseBracket = 48,
	Pipe = 49,
	Tilde = 50,
	Semicolon = 51,
	Quote = 52,
	Backquote = 53,
	Comma = 54,
	Period = 55,
	Slash = 56,
	CapsLock = 57,
	F1 = 58,
	F2 = 59,
	F3 = 60,
	F4 = 61,
	F5 = 62,
	F6 = 63,
	F7 = 64,
	F8 = 65,
	F9 = 66,
	F10 = 67,
	F11 = 68,
	F12 = 69,
	PrintScreen = 70,
	ScrollLock = 71,
	Pause = 72,
	Insert = 73,
	Home = 74,
	PageUp = 75,
	Delete = 76,
	End = 77,
	PageDown = 78,
	RightArrow = 79,
	LeftArrow = 80,
	DownArrow = 81,
	UpArrow = 82,
	NumLock = 83,
	NumPadDivide = 84,
	NumPadMultiply = 85,
	NumPadSubtract = 86,
	NumPadAdd = 87,
	NumPadEnter = 88,
	NumPad1 = 89,
	NumPad2 = 90,
	NumPad3 = 91,
	NumPad4 = 92,
	NumPad5 = 93,
	NumPad6 = 94,
	NumPad7 = 95,
	NumPad8 = 96,
	NumPad9 = 97,
	NumPad0 = 98,
	NumPadDot = 99,
	Backslash = 100,
	Application = 101,
	Power = 102,
	NumPadEquals = 103,
	F13 = 104,
	F14 = 105,
	F15 = 106,
	F16 = 107,
	F17 = 108,
	F18 = 109,
	F19 = 110,
	F20 = 111,
	F21 = 112,
	F22 = 113,
	F23 = 114,
	F24 = 115,
	NumPadComma = 133,
	Ro = 135,
	KatakanaHiragana = 136,
	Yen = 137,
	Henkan = 138,
	Muhenkan = 139,
	NumPadCommaPc98 = 140,
	HangulEnglish = 144,
	Hanja = 145,
	Katakana = 146,
	Hiragana = 147,
	ZenkakuHankaku = 148,
	LeftControl = 224,
	LeftShift = 225,
	LeftAlt = 226,
	LeftGui = 227,
	RightControl = 228,
	RightShift = 229,
	RightAlt = 230,
	RightGui = 231,
};

enum class KeyboardModifier { Control, Shift, LeftAlt, RightAlt, Gui, CapsLock, ScrollLock, NumLock, Katakana, Hiragana };

enum class DebugPadButton { A, B, X, Y, L, R, ZL, ZR, Start, Select, Left, Up, Right, Down };

enum class DebugPadAttribute { IsConnected };

enum class BasicXpadButton {};

enum class BasicXpadAttribute {};

enum class GestureType { Idle, Complete, Cancel, Touch, Press, Tap, Pan, Swipe, Pinch, Rotate };

enum class GestureDirection { None, Left, Up, Right, Down };

enum class GestureAttribute { IsNewTouch = 4, IsDoubleTap = 8 };

enum class SixAxisSensorAttribute { IsConnected, IsInterpolated };

enum class NpadJoyAssignmentMode { Dual, Single };

enum class DigitizerAttribute {};

enum class DigitizerButton {};

typedef nn::util::BitFlagSet<32, NpadAttribute> NpadAttributeSet;
typedef nn::util::BitFlagSet<64, NpadButton> NpadButtonSet;
typedef nn::util::BitFlagSet<32, NpadStyleTag> NpadStyleSet;
typedef nn::util::BitFlagSet<32, MouseButton> MouseButtonSet;
typedef nn::util::BitFlagSet<32, MouseAttribute> MouseAttributeSet;
typedef nn::util::BitFlagSet<32, TouchAttribute> TouchAttributeSet;
typedef nn::util::BitFlagSet<32, DebugPadButton> DebugPadButtonSet;
typedef nn::util::BitFlagSet<32, DebugPadAttribute> DebugPadAttributeSet;
typedef nn::util::BitFlagSet<32, BasicXpadButton> BasicXpadButtonSet;
typedef nn::util::BitFlagSet<32, BasicXpadAttribute> BasicXpadAttributeSet;
typedef nn::util::BitFlagSet<32, GestureAttribute> GestureAttributeSet;
typedef nn::util::BitFlagSet<32, SixAxisSensorAttribute> SixAxisSensorAttributeSet;
typedef nn::util::BitFlagSet<32, DigitizerAttribute> DigitizerAttributeSet;
typedef nn::util::BitFlagSet<32, DigitizerButton> DigitizerButtonSet;

struct AnalogStickState {
	s32 mX;
	s32 mY;
};

struct ControllerSupportArg {
	u8 mMinPlayerCount;
	u8 mMaxPlayerCount;
	u8 mTakeOverConnection;
	bool mLeftJustify;
	bool mPermitJoyconDual;
	bool mSingleMode;
	bool mUseColors;
	Color4u8 mColors[4];
	u8 mUsingControllerNames;
	char mControllerNames[4][0x81];
};

struct ControllerSupportResultInfo {
	int mPlayerCount;
	int mSelectedId;
};

struct NpadControllerColor {
	Color4u8 mMain;
	Color4u8 mSub;
};

struct DebugPadState {
	u64 mSamplingNumber;
	DebugPadAttributeSet mAttributes;
	DebugPadButtonSet mButtons;
	AnalogStickState mAnalogStickR;
	AnalogStickState mAnalogStickL;
};

struct TouchState {
	u64 mDeltaTime;
	TouchAttributeSet mAttributes;
	s32 mFingerId;
	s32 mX;
	s32 mY;
	s32 mDiameterX;
	s32 mDiameterY;
	s32 mRotationAngle;
};

template <u64 N>
struct TouchScreenState {
	u64 mSamplingNumber;
	s32 mCount;
	TouchState mTouches[N];
};

struct MouseState {
	u64 mSamplingNumber;
	s32 mX;
	s32 mY;
	s32 mDeltaX;
	s32 mDeltaY;
	s32 mWheelDeltaX;
	s32 mWheelDeltaY;
	MouseButtonSet mButtons;
	MouseAttributeSet mAttributes;
};

struct KeyboardState {
	u64 mSamplingNumber;
	nn::util::BitFlagSet<32, KeyboardModifier> mModifiers;
	nn::util::BitFlagSet<256, KeyboardKey> mKeys;
};

struct BasicXpadState {
	u64 mSamplingNumber;
	BasicXpadAttributeSet mAttributes;
	BasicXpadButtonSet mButtons;
	AnalogStickState mAnalogStickR;
	AnalogStickState mAnalogStickL;
};

struct NpadBaseState {
	u64 mSamplingNumber;
	NpadButtonSet mButtons;
	AnalogStickState mAnalogStickL;
	AnalogStickState mAnalogStickR;
	NpadAttributeSet mAttributes;
};

struct NpadFullKeyState : NpadBaseState {};

struct NpadHandheldState : NpadBaseState {};

struct NpadJoyDualState : NpadBaseState {};

struct NpadJoyLeftState : NpadBaseState {};

struct NpadJoyRightState : NpadBaseState {};

struct NpadPalmaState : NpadBaseState {};

struct DirectionState {
	f32 mMat[3][3];
};

struct SixAxisSensorState {
	u64 mDeltaTime;
	u64 mSamplingNumber;
	f32 mAcceleration[3];
	f32 mAngularVelocity[3];
	f32 mAngle[3];
	DirectionState mDirection;
	SixAxisSensorAttributeSet mAttributes;
};

struct GesturePoint {
	s32 mX;
	s32 mY;
};

struct GestureDummyState {
	u64 mSamplingNumber;
	u64 mContextNumber;
	GestureType mType;
	GestureDirection mDirection;
	s32 mX;
	s32 mY;
	s32 mDeltaX;
	s32 mDeltaY;
	f32 mVelocityX;
	f32 mVelocityY;
	GestureAttributeSet mAttributes;
	s32 mScale;
	s32 mRotationAngle;
	s32 mPointCount;
	GesturePoint mPoint[4];
};

struct DigitizerState {
	u64 mSamplingNumber;
	u8 padding_8[0x8];
	DigitizerAttributeSet mAttributes;
	DigitizerButtonSet mButtons;
	u8 padding[0x40];
};

void InitializeNpad();
void SetSupportedNpadIdType(const u32*, u64);
void SetSupportedNpadStyleSet(NpadStyleSet);
NpadStyleSet GetNpadStyleSet(const u32& port);
int ShowControllerSupport(ControllerSupportResultInfo*, const ControllerSupportArg&);

void GetNpadState(NpadFullKeyState*, const u32& port);
void GetNpadState(NpadHandheldState*, const u32& port);
void GetNpadState(NpadJoyDualState*, const u32& port);
void GetNpadState(NpadJoyLeftState*, const u32& port);
void GetNpadState(NpadJoyRightState*, const u32& port);

void GetNpadStates(NpadFullKeyState*, int, const u32& port);
void GetNpadStates(NpadHandheldState*, int, const u32& port);
void GetNpadStates(NpadJoyDualState*, int, const u32& port);
void GetNpadStates(NpadJoyLeftState*, int, const u32& port);
void GetNpadStates(NpadJoyRightState*, int, const u32& port);

void InitializeMouse();
void InitializeKeyboard();

void GetMouseState(MouseState*);
void GetKeyboardState(KeyboardState*);

namespace system {

typedef u8 UniquePadSerialNumber[0x10];
typedef u32 BatteryLevel;

enum class UniquePadType { Embedded, FullKeyController, RightController, LeftController, DebugPadController };

enum class UniquePadInterface { Embedded, Rail, Bluetooth, Usb };

enum class HomeButton {};

enum class SleepButton {};

enum class CaptureButton {};

enum class AnalogStickManualCalibrationStage : u64 {
	ReleaseFromRight,
	ReleaseFromBottom,
	ReleaseFromLeft,
	ReleaseFromTop,
	Rotate,
	Update,
	Completed,
	Clear,
	ClearCompleted
};

enum class SixAxisSensorUserCalibrationStage : u64 { Measuring, Update, Completed };

enum class DeviceType {
	FullKey,
	DebugPad,
	HandheldLeft,
	HandheldRight,
	JoyLeft,
	JoyRight,
	Palma,
	LarkHvcLeft,
	LarkHvcRight,
	LarkNesLeft,
	LarkNesRight,
	HandheldLarkHvcLeft,
	HandheldLarkHvcRight,
	HandheldLarkNesLeft,
	HandheldLarkNesRight,
	Lucia,
	Lagon,
	Lager,
	System = 31
};

typedef nn::util::BitFlagSet<32, HomeButton> HomeButtonSet;
typedef nn::util::BitFlagSet<32, SleepButton> SleepButtonSet;
typedef nn::util::BitFlagSet<32, CaptureButton> CaptureButtonSet;

struct HomeButtonState {
	u64 mSamplingNumber;
	HomeButtonSet mButtons;
};

struct SleepButtonState {
	u64 mSamplingNumber;
	SleepButtonSet mButtons;
};

struct CaptureButtonState {
	u64 mSamplingNumber;
	CaptureButtonSet mButtons;
};

struct NpadSystemState : NpadBaseState {};

struct NpadSystemExtState : NpadBaseState {};

struct InputSourceState {
	u64 mTimestamp;
};

} // namespace system

namespace tmp {

struct SixAxisSensorCountState {
	u8 padding[0x28];
};

} // namespace tmp

namespace detail {

template <typename T>

class AtomicStorage {
public:
	u64 mSamplingNumber;
	T mStorage;
};

template <typename T, s32 N, typename Atomic>
class RingLifo {
public:
	virtual ~RingLifo() = default;

	u64 mBufferCount = N + 1;
	u64 mTail;
	u64 mCount = N;
	Atomic mStorage[N + 1];
};

} // namespace detail

namespace server {

typedef detail::RingLifo<DigitizerState, 16, detail::AtomicStorage<DigitizerState>> DigitizerLifo;

struct DigitizerSharedMemoryFormat {
	DigitizerLifo mLifo;
	u8 padding[0x1000 - sizeof(DigitizerLifo)];
};

} // namespace server

namespace detail {

enum class AnalogStickCalibrationFlags {};
enum class SixAxisSensorUserCalibrationFlags {};
enum class ColorAttribute { Ok, ReadError, NoController };

typedef AtomicStorage<TouchScreenState<16>> TouchScreenStateAtomicStorage;

typedef nn::util::BitFlagSet<32, AnalogStickCalibrationFlags> AnalogStickCalibrationFlagsSet;
typedef nn::util::BitFlagSet<32, SixAxisSensorUserCalibrationFlags> SixAxisSensorUserCalibrationFlagsSet;
typedef nn::util::BitFlagSet<64, NpadSystemProperties> NpadSystemPropertiesSet;
typedef nn::util::BitFlagSet<32, NpadSystemButtonProperties> NpadSystemButtonPropertiesSet;

struct InputDetectorState {
	system::InputSourceState mInputSourceState;
	u64 mSamplingNumber;
};

struct UniquePadConfig {
	system::UniquePadType mType;
	system::UniquePadInterface mInterface;
	system::UniquePadSerialNumber mSerialNumber;
	u32 mControllerNumber;
	bool mIsActive;
	u64 mSamplingNumber;
};

struct AnalogStickCalibrationStateImpl {
	AnalogStickState mState;
	AnalogStickCalibrationFlagsSet mFlags;
	system::AnalogStickManualCalibrationStage mStage;
	u64 mSamplingNumber;
};

struct SixAxisSensorUserCalibrationState {
	SixAxisSensorUserCalibrationFlagsSet mFlags;
	system::SixAxisSensorUserCalibrationStage mStage;
	u64 mSamplingNumber;
};

struct NfcXcdDeviceHandleStateImpl {
	xcd::DeviceHandle mHandle;
	bool mIsAvailable;
	bool mIsActivated;
	u64 mSamplingNumber;
};

typedef RingLifo<MouseState, 16, AtomicStorage<MouseState>> MouseLifo;
typedef RingLifo<DebugPadState, 16, AtomicStorage<DebugPadState>> DebugPadLifo;
typedef RingLifo<KeyboardState, 16, AtomicStorage<KeyboardState>> KeyboardLifo;
typedef RingLifo<BasicXpadState, 16, AtomicStorage<BasicXpadState>> BasicXpadLifo;
typedef RingLifo<NpadFullKeyState, 16, AtomicStorage<NpadFullKeyState>> NpadFullKeyLifo;
typedef RingLifo<NpadJoyDualState, 16, AtomicStorage<NpadJoyDualState>> NpadJoyDualLifo;
typedef RingLifo<NpadJoyLeftState, 16, AtomicStorage<NpadJoyLeftState>> NpadJoyLeftLifo;
typedef RingLifo<TouchScreenState<16ul>, 16, TouchScreenStateAtomicStorage> TouchScreenLifo;
typedef RingLifo<NpadHandheldState, 16, AtomicStorage<NpadHandheldState>> NpadHandheldLifo;
typedef RingLifo<NpadJoyRightState, 16, AtomicStorage<NpadJoyRightState>> NpadJoyRightLifo;
typedef RingLifo<tmp::SixAxisSensorCountState, 32, AtomicStorage<tmp::SixAxisSensorCountState>> SixAxisSensorCountStateLifo;
typedef RingLifo<system::HomeButtonState, 16, AtomicStorage<system::HomeButtonState>> HomeButtonLifo;
typedef RingLifo<system::NpadSystemState, 16, AtomicStorage<system::NpadSystemState>> NpadSystemLifo;
typedef RingLifo<system::SleepButtonState, 16, AtomicStorage<system::SleepButtonState>> SleepButtonLifo;
typedef RingLifo<system::CaptureButtonState, 16, AtomicStorage<system::CaptureButtonState>> CaptureButtonLifo;
typedef RingLifo<system::NpadSystemExtState, 16, AtomicStorage<system::NpadSystemExtState>> NpadSystemExtLifo;
typedef RingLifo<UniquePadConfig, 1, AtomicStorage<UniquePadConfig>> UniquePadConfigLifo;
typedef RingLifo<GestureDummyState, 16, AtomicStorage<GestureDummyState>> GestureLifo;
typedef RingLifo<InputDetectorState, 1, AtomicStorage<InputDetectorState>> InputDetectorLifo;
typedef RingLifo<NfcXcdDeviceHandleStateImpl, 1, AtomicStorage<NfcXcdDeviceHandleStateImpl>> NfcXcdDeviceHandleState;
typedef RingLifo<AnalogStickCalibrationStateImpl, 1, AtomicStorage<AnalogStickCalibrationStateImpl>> AnalogStickCalibrationStateImplLifo;
typedef RingLifo<SixAxisSensorUserCalibrationState, 1, AtomicStorage<SixAxisSensorUserCalibrationState>> SixAxisSensorUserCalibrationStateLifo;
typedef RingLifo<SixAxisSensorState, 16, AtomicStorage<SixAxisSensorState>> NpadSixAxisSensorLifo;
typedef RingLifo<SixAxisSensorState, 32, AtomicStorage<SixAxisSensorState>> SixAxisSensorStateLifo;

struct DebugPadSharedMemoryFormat {
	DebugPadLifo mLifo;
	u8 padding[0x400 - sizeof(DebugPadLifo)];
};

struct TouchScreenSharedMemoryFormat {
	TouchScreenLifo mLifo;
	u8 padding[0x3000 - sizeof(TouchScreenLifo)];
};

struct MouseSharedMemoryFormat {
	MouseLifo mLifo;
	u8 padding[0x400 - sizeof(MouseLifo)];
};

struct KeyboardSharedMemoryFormat {
	KeyboardLifo mLifo;
	u8 padding[0x400 - sizeof(KeyboardLifo)];
};

struct BasicXpadSharedMemoryEntry {
	BasicXpadLifo mLifo;
	u8 padding[0x400 - sizeof(BasicXpadLifo)];
};

struct BasicXpadSharedMemoryFormat {
	BasicXpadSharedMemoryEntry mEntries[4];
};

struct HomeButtonSharedMemoryFormat {
	HomeButtonLifo mLifo;
	u8 padding[0x200 - sizeof(HomeButtonLifo)];
};

struct SleepButtonSharedMemoryFormat {
	SleepButtonLifo mLifo;
	u8 padding[0x200 - sizeof(SleepButtonLifo)];
};

struct CaptureButtonSharedMemoryFormat {
	CaptureButtonLifo mLifo;
	u8 padding[0x200 - sizeof(CaptureButtonLifo)];
};

struct InputDetectorSharedMemoryEntry {
	InputDetectorLifo mLifo;
	u8 padding[0x80 - sizeof(InputDetectorLifo)];
};

struct InputDetectorSharedMemoryFormat {
	InputDetectorSharedMemoryEntry mEntries[16];
};

struct UniquePadSharedMemoryEntry {
	UniquePadConfigLifo mUniquePadConfigLifo;
	AnalogStickCalibrationStateImplLifo mAnalogStickCalibrationStateImplLifo[2];
	SixAxisSensorUserCalibrationStateLifo mSixAxisSensorUserCalibrationStateLifo;
	os::MutexType mMutex;
	u8 padding[0x220];
};

struct UniquePadSharedMemoryFormat {
	UniquePadSharedMemoryEntry mEntries[16];
};

struct NpadFullKeyColorState {
	ColorAttribute mAttribute;
	NpadControllerColor mFullKey;
};

struct NpadJoyColorState {
	ColorAttribute mAttribute;
	NpadControllerColor mLeft;
	NpadControllerColor mRight;
};

struct NpadInternalState {
	NpadStyleSet mStyleSet;
	NpadJoyAssignmentMode mJoyAssignmentMode;
	NpadFullKeyColorState mFullKeyColor;
	NpadJoyColorState mJoyColor;
	NpadFullKeyLifo mFullKeyLifo;
	NpadHandheldLifo mHandheldLifo;
	NpadJoyDualLifo mJoyDualLifo;
	NpadJoyLeftLifo mJoyLeftLifo;
	NpadJoyRightLifo mJoyRightLifo;
	NpadSystemLifo mSystemLifo;
	NpadSystemExtLifo mSystemExtLifo;
	NpadSixAxisSensorLifo mFullKeySixAxisSensorLifo;
	NpadSixAxisSensorLifo mHandheldSixAxisSensorLifo;
	NpadSixAxisSensorLifo mJoyDualLeftSixAxisSensorLifo;
	NpadSixAxisSensorLifo mJoyDualRightSixAxisSensorLifo;
	NpadSixAxisSensorLifo mJoyLeftSixAxisSensorLifo;
	NpadSixAxisSensorLifo mJoyRightSixAxisSensorLifo;
	system::DeviceType mDeviceType;
	NpadSystemPropertiesSet mSystemProperties;
	NpadSystemButtonPropertiesSet mSystemButtonProperties;
	system::BatteryLevel mBatteryLevelJoyDual;
	system::BatteryLevel mBatteryLevelJoyLeft;
	system::BatteryLevel mBatteryLevelJoyRight;
	NfcXcdDeviceHandleState mNfcXcdDeviceHandle;
	os::MutexType mMutex;
};

struct NpadSharedMemoryEntry {
	NpadInternalState mInternalState;
	u8 padding[0x5000 - sizeof(NpadInternalState)];
};

struct NpadSharedMemoryFormat {
	NpadSharedMemoryEntry mEntries[10];
};

struct GestureSharedMemoryFormat {
	GestureLifo mLifo;
	u8 padding[0x800 - sizeof(GestureLifo)];
};

struct SixAxisSensorSharedMemoryFormat {
	SixAxisSensorCountStateLifo mCountStateLifo;
	SixAxisSensorStateLifo mStateLifo;
	u8 padding[0xc28];
};

struct SharedMemoryFormat {
	DebugPadSharedMemoryFormat mDebugPad;
	TouchScreenSharedMemoryFormat mTouchScreen;
	MouseSharedMemoryFormat mMouse;
	KeyboardSharedMemoryFormat mKeyboard;
#if NN_SDK_VER <= NN_MAKE_VER(9, 2, 0)
	BasicXpadSharedMemoryFormat mBasicXpad;
#else
	server::DigitizerSharedMemoryFormat mDigitizer;
#endif
	HomeButtonSharedMemoryFormat mHomeButton;
	SleepButtonSharedMemoryFormat mSleepButton;
	CaptureButtonSharedMemoryFormat mCaptureButton;
	InputDetectorSharedMemoryFormat mInputDetector;
#if NN_SDK_VER <= NN_MAKE_VER(4, 1, 0)
	UniquePadSharedMemoryFormat mUniquePad;
#else
	u8 padding_5a00[sizeof(UniquePadSharedMemoryFormat)];
#endif
	NpadSharedMemoryFormat mNpad;
	GestureSharedMemoryFormat mGesture;
	SixAxisSensorSharedMemoryFormat mSixAxisSensor;
	u8 padding_3e200[0x1e00];
};

struct SharedMemoryType {
	u8 padding[0x40];
};

struct SharedMemoryHolder {
	bool mIsOwner;
	bool mIsCreated;
	bool mIsMapped;
	SharedMemoryType mSharedMemory;
	SharedMemoryFormat* mAddress;
};

} // namespace detail
} // namespace hid
} // namespace nn
